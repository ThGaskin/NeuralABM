# Generate densities by drawing from the joint distribution of the parameters
densities_from_joint:
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.errorbands
    - .cycler_green_red_green
  select_and_combine:
    fields:
      parameters:
        path: parameters
        transform: [.data]
      probabilities:
        path: loss
        transform: [neg_exp]
      true_data:
        path: true_counts
        transform: [.data]
        subspace:
          seed: [ 0 ]
      cfg:
        path: ../../cfg
        transform:
          - getitem: [!dag_prev , 'SIR']
        subspace:
          seed: [0]
  transform:

    # Flatten the cfg
    - .data: [!dag_tag cfg]
    - getitem: [!dag_prev , 0]
      tag: cfg_flattened

    # Flatten the true counts
    - .isel: [!dag_tag true_data, {seed: 0}]
      kwargs: {drop: True}
      tag: true_data_flattened

    # Flatten the probabilities and parameters
    - flatten_dims: [!dag_tag probabilities ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: prob
    - flatten_dims: [!dag_tag parameters ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: params

    # Get the bins for each parameter
    - xr.DataArray:
        data: [100, 100]
        dims: [ 'idx' ]

    # Get the unnormalised joint distribution and set nan entries to zero (they will be skipped in the density
    # calculation)
    - joint_2D_ds: [!dag_tag params, !dag_tag prob, !dag_prev ]
      kwargs:
        x: p_infect
        y: t_infectious
      tag: joint
    - .fillna: [!dag_prev , 0]
    - SIR_densities_from_joint: [!dag_prev ]
      kwargs:
        true_counts: !dag_tag true_data_flattened
        cfg: !dag_tag cfg_flattened
      file_cache:
        read: True
        write: True
      tag: densities

    # No point plotting the mode, as sampling from sigma will produce a single stochastic process, rather than an
    # average
    - .sel: [!dag_prev , {type: prediction_mean}]
      tag: data

    # Get the true data
    - .sel: [!dag_node -2 , {type: true_counts}]
      kwargs: {drop: True}
    - getitem: [!dag_prev , mean]
      tag: true_counts
  x: time
  y: mean
  yerr: std
  hue: kind
  sharey: False
  add_legend: False
  helpers:
    set_legend:
      use_legend: False
    set_labels:
      x: ' '
      y: ' '
    call:
      functions:
        - function: [xarray.plot, line]
          args: [!dag_result true_counts]
          x: time
          hue: kind
          lw: 0
          add_legend: False
          marker: 'o'
          markeredgecolor: !dag_result c_darkgrey
          markeredgewidth: 0.1
          markersize: 1.5
          zorder: 20
          _labels: False
  style:
    figure.figsize: [ !dag_result half_width, !dag_result quarter_width ]
    # No idea why this is necessary ...
    axes.prop_cycle: !format
      fstr: "cycler('color', ['{colors[red]:}','{colors[darkgreen]:}','{colors[lightgreen]:}', '{colors[lightgreen]:}'])"
      colors:
        lightgreen: '#AFD8BC'
        darkgreen: '#48675A'
        red: '#ec7070'
  file_ext: pdf

# Plot the marginals together
marginals_all:
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.density
  select_and_combine:
    fields:
      parameters: parameters
      probabilities:
        path: loss
        transform: [neg_exp]
  transform:

    # Flatten the prob and parameter samples into a single dimension
    - flatten_dims: [!dag_tag probabilities ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: prob
    - flatten_dims: [!dag_tag parameters ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: params
    - joint_2D_ds: [!dag_tag params, !dag_tag prob, [100, 30]]
      kwargs:
        x: p_infect
        y: t_infectious
    - marginal_from_joint: [!dag_prev ]
      kwargs:
        parameter: p_infect
    - marginal_from_joint: [!dag_node -2]
      kwargs:
        parameter: t_infectious
    - concat_along: [[!dag_node -2, !dag_prev ], 'parameter', ['p_infect', 't_infectious']]
      tag: data
  c: !dag_result c_darkblue
  x: x
  y: y
  col: parameter
  sharex: False
  sharey: False

# Plot the marginals as individual frames
marginals: !pspace
  dag_options:
    meta_operations:
      load_csv:
        - import_and_call: [ pandas, read_csv, !arg 0 ]
          kwargs: { index_col: !kwarg index_col }
    define:
      parameter: !sweep
        default: 'p_infect'
        values: ['p_infect', 't_infectious']
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.density
    - .cycler_marginals
  select_and_combine:
    fields:
      parameters:
        path: parameters
      probabilities:
        path: loss
        transform: [neg_exp]
  transform:

    # --- Calculate the neural marginals -------------------------------------------------------------------------------
    - xr.DataArray:
        data: [100, 100]
        dims: ['idx']
      tag: bins
    # Flatten the prob and parameter samples into a single dimension
    - flatten_dims: [!dag_tag probabilities ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: prob
    - flatten_dims: [!dag_tag parameters ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: params

    - joint_2D_ds: [!dag_tag params, !dag_tag prob, !dag_tag bins]
      kwargs:
        x: p_infect
        y: t_infectious
    - marginal_from_joint: [!dag_prev ]
      kwargs: {parameter: !dag_tag parameter, scale_y_bins: False}
      tag: neural_marginal

      # --- Load the ground truth --------------------------------------------------------------------------------------
    - load_csv: ['data/SIR/ground_truth.csv']
      kwargs: {index_col: [0, 1]}
    - .to_xarray: [!dag_prev ]
    - .sel: [!dag_prev , {parameter: !dag_tag parameter}]
      kwargs: {drop: True}
      tag: ground_truth
    - getitem: [!dag_prev , 'x']
      tag: ground_truth_x
    - getitem: [!dag_node -2, 'y']
      tag: ground_truth_y

      # --- Calculate the MCMC marginals -------------------------------------------------------------------------------
    - load_csv: ['data/SIR/MCMC_data.csv']
      kwargs: { index_col: [0, 1]}
    - .to_xarray: [!dag_prev ]
    - getitem: [!dag_prev , 'value']
      tag: MCMC_samples
    - .coords: [!dag_prev , 'parameter']
      tag: MCMC_parameter_coords
    - xr.DataArray:
        data: [100, 100, 100]
        dims: ['parameter']
    - .assign_coords: [!dag_prev , {parameter: !dag_tag MCMC_parameter_coords}]
      tag: MCMC_bins
    - xr.DataArray:
        data: [[0, 1], [0, 1], [1, 30]]
        dims: ['parameter', 'idx']
    - .assign_coords: [!dag_prev , {parameter: !dag_tag MCMC_parameter_coords}]
      tag: MCMC_ranges
    - hist: [!dag_tag MCMC_samples , !dag_tag MCMC_bins , !dag_tag MCMC_ranges]
      kwargs:
        exclude_dim: [parameter]
        dim: 'sample'
    - .rename: [!dag_prev , {count: y}]
    - normalize: [!dag_prev ]
      kwargs:
        x: 'x'
        y: 'y'
        exclude_dim: [parameter]
    - .sel: [!dag_prev , {parameter: !dag_tag parameter}]
      kwargs: {drop: True}
      tag: MCMC_marginal

    # Combine neural and MCMC estimates into a single dataset
    - concat_along: [[!dag_tag neural_marginal, !dag_tag MCMC_marginal], 'kind', ['Neural', 'MALA']]
      tag: data

    # Calculate the Hellinger distances and print
    - Hellinger_distance: [!dag_tag neural_marginal, !dag_tag ground_truth]
      kwargs: {x: x, y: y}
    - print: [!dag_prev ]
      tag: Hellinger_neural
    - Hellinger_distance: [ !dag_tag MCMC_marginal, !dag_tag ground_truth ]
      kwargs: {x: x, y: y}
    - print: [!dag_prev ]
      tag: Hellinger_MCMC

  compute_only: [data, Hellinger_neural, Hellinger_MCMC]
  x: x
  y: y
  hue: kind
  smooth_kwargs:
    t_infectious:
      enabled: True
      smoothing: 1
  helpers:
    call:
      functions:
        - function: [ matplotlib, pyplot.plot ]
          args: [ !dag_result ground_truth_x, !dag_result ground_truth_y ]
          color: !dag_result c_darkgrey
          label: Ground truth
          linestyle: dotted
    set_labels:
      y: ' '
    set_legend:
      use_legend: !coupled-sweep
        default: true
        target_name: parameter
        values: [true, false]
  style:
    figure.figsize: [!dag_result half_width, !dag_result quarter_width]

# Plot the initial value distribution on the parameters
initial_values:
  based_on:
    - .creator.multiverse
    - .plot.multiplot
  select_and_combine:
    fields:
      parameters:
        path: parameters
        transform:
          - .isel: [!dag_prev , {batch: 0}]
  transform:
    - .isel: [!dag_tag parameters, {parameter: 0}]
      tag: p
    - .isel: [!dag_tag parameters, {parameter: 1}]
      tag: t
  to_plot:
    [0, 0]:
      - function: sns.histplot
        data: !dag_result p
    [1, 0]:
      - function: sns.histplot
        data: !dag_result t
  color: !dag_result c_darkblue
  linewidth: 0.5
  helpers:
    axis_specific:
      0:
        axis: [0, 0]
        set_labels:
          x: $\beta$
      1:
        axis: [ 1, 0 ]
        set_labels:
          x: $\tau$
    setup_figure:
      nrows: 1
      ncols: 2
    set_labels:
      y: ' '
  compute_only: []
  style:
    figure.figsize: [!dag_result full_width, !dag_result quarter_width]

# Plot the predictions over time, colour-coded by loss
predictions:
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.scatter
  select_and_combine:
    fields:
      parameters:
        path: parameters
        transform: [.data]
      loss:
        path: loss
        transform: [.data]
  transform:
    - broadcast: [!dag_tag parameters, !dag_tag loss]
      kwargs:
        exclude_dim: [seed]
    - flatten_dims: [!dag_prev ]
      kwargs:
        dims: {batch: [batch, seed]}
      tag: data
  x: batch
  y: x
  hue: loss
  col: parameter
  s: 2
  sharey: False # Seems to have no effect?
  sharex: False
  helpers:
    set_limits:
      x: [min, max]
      y: [0, max] # Why is this necessary?
  add_legend: False
  norm:
    name: LogNorm
  vmax: 100
  cmap: &cmap
    continuous: true
    from_values:
      0: !dag_result c_darkblue
      1: !dag_result c_yellow

# Plot the loss landscape of the parameters, colour-coded by loss
probability_landscape:
  based_on: predictions
  add_legend: False
  select_and_combine:
    fields:
      loss:
        transform:
          - mul: [!dag_prev , -1]
          - np.exp: [!dag_prev ]
  x: x
  y: loss
  hue: loss
  s: 2
  norm: ~
  vmax: ~
  cbar_kwargs:
    label: Unnormalised probability

# Plot the joint
joint:
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.pcolormesh
  select_and_combine:
    fields:
      parameters: parameters
      probabilities:
        path: loss
        transform: [neg_exp]
  transform:
    # Flatten the prob and parameter samples into a single dimension
    - flatten_dims: [!dag_tag probabilities ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: prob
    - flatten_dims: [!dag_tag parameters ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: params

    # Compute the joint
    - joint_2D_ds: [!dag_tag params, !dag_tag prob]
      kwargs:
        x: p_infect
        y: t_infectious
      tag: data
  x: p_infect
  y: t_infectious
  cmap:
    <<: *cmap
  cbar_kwargs:
    label: ~
  style:
    figure.figsize: [!dag_result half_width, !dag_result half_width]

# Plot the density of samples in 2D
point_density:
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.pcolormesh
    - joint
  select_and_combine:
    fields:
      parameters: parameters
      loss:
        path: loss
  transform:
    # Flatten the prob and parameter samples into a single dimension
    - flatten_dims: [!dag_tag probabilities ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: prob
    - flatten_dims: [!dag_tag parameters ]
      kwargs:
        dims: {sample: [batch, seed]}
      tag: params

    - joint_2D_ds: [!dag_tag params, !dag_tag prob]
      kwargs:
        statistic: count
        x: p_infect
        y: t_infectious
      tag: data
  x: p_infect
  y: t_infectious
  vmin: 1
  norm:
    name: LogNorm
  cmap:
    <<: *cmap
  cbar_kwargs:
    label: ~
  style:
    figure.figsize: [!dag_result half_width, !dag_result half_width]
