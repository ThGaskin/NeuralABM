# ======================================================================================================================
#  ╔═╗╦╦═╗  ╔╦╗╔═╗╔╗╔╔═╗╦╔╦╗╦╔═╗╔═╗
#  ╚═╗║╠╦╝   ║║║╣ ║║║╚═╗║ ║ ║║╣ ╚═╗
#  ╚═╝╩╩╚═  ═╩╝╚═╝╝╚╝╚═╝╩ ╩ ╩╚═╝╚═╝
# ======================================================================================================================
# Generate densities by drawing from the joint distribution of the parameters
densities_from_joint:
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.errorbands
    - .joint_mv
  select_and_combine:
    fields:
      true_data:
        path: true_counts
        transform: [.data]
        subspace:
          seed: [ 0 ]
      cfg:
        path: ../../cfg
        transform:
          - getitem: [!dag_prev , 'SIR']
        subspace:
          seed: [0]
  transform:
    # Flatten the cfg
    - .data: [!dag_tag cfg]
    - getitem: [!dag_prev , 0]
      tag: cfg_flattened

    # Flatten the true counts
    - .isel: [!dag_tag true_data, {seed: 0}]
      kwargs: {drop: True}
      tag: true_data_flattened

    # Get the normalized joint distribution
    - get_joint: [!dag_tag parameters, !dag_tag probabilities]
      kwargs:
        bins: 100
        range: [[0, 1], [1, 30], [0, 0.5]]
        normalize: True
        differential: 1
      file_cache:
        read: True
        write: True
      tag: joint
    - getitem: [!dag_prev , 'mean']
    - .fillna: [!dag_prev , 0]
    - SIR_densities_from_joint: [!dag_prev ]
      kwargs:
        true_counts: !dag_tag true_data_flattened
        cfg: !dag_tag cfg_flattened
      file_cache:
        read: True
        write: True
    # No point plotting the mode, as sampling from sigma will produce a single stochastic process, rather than an
    # average
    - .sel: [!dag_prev , {type: [true_counts, prediction_mean]}]
      tag: data
  x: time
  y: mean
  yerr: std
  hue: type
  col: kind
  sharey: False
  add_legend: False
  figsize: [ !dag_result full_width, !dag_result third_width ]
  helpers:
    set_labels:
      y: ' '
    axis_specific:
      0:
        axis: [0, 0]
        set_legend:
          use_legend: True
          gather_from_fig: True
  style:
    axes.prop_cycle: !format
      fstr: "cycler('color', ['{colors[darkblue]:}', '{colors[orange]:}'])"
      colors:
        darkblue: '#2F7194'
        orange: '#EC9F7E'
  file_ext: pdf

# Plot the marginals on the parameters
marginals:
  based_on:
    - .marginal_mv
    - .plot.facet_grid.density
  transform:
    # Get the bin edges and ranges for each parameter:
    # the intervals given by the prior, and a high bin count to ensure points that are not equal are not
    # averaged together
    - xr.DataArray:
        data: [[0, 1, 1000], [1, 30, 1000], [0, 1, 1000]]
        dims: ['parameter', 'idx']
        coords: {parameter: [p_infect, t_infectious, sigma]}
      tag: bins
    - get_marginals: [!dag_tag parameters, !dag_tag probabilities, !dag_tag bins]
      kwargs:
        statistic: mean
        exclude_dim: [ parameter ]
        flatten_dims: {sample: [ seed, batch ] }
      tag: data
  x: x
  y: p
  col: parameter
  helpers:
    set_labels:
      y: ' '
  smooth_kwargs:
    enabled: True
    sigma: 20
  style:
    figure.figsize: [!dag_result half_width, !dag_result quarter_width]

# Plot the joint distribution over p_infect and t_infectious
joint:
  based_on:
    - .joint_mv
    - .plot.facet_grid.pcolormesh
  transform:
    - get_joint: [!dag_tag parameters , !dag_tag probabilities ]
      kwargs: {bins: 100, range: ~, normalize: False, differential: ~}
    - getitem: [!dag_prev , 'mean']
    - .sum: [!dag_prev , 'sigma']
      tag: data
  x: p_infect
  y: t_infectious
  helpers:
    set_labels:
      x: $\beta$
      y: $\tau$
  cmap: &cmap
    continuous: true
    from_values:
      0: !dag_result c_darkblue
      1: !dag_result c_yellow
  cbar_kwargs:
    label: ~

# Plot the prior densities on the parameters
priors:
  based_on:
    - .creator.multiverse
    - .plot.multiplot
  select_and_combine:
    fields:
      parameters:
        path: parameters
        transform:
          - .isel: [!dag_prev , {batch: 0}]
  transform:
    - .isel: [!dag_tag parameters, {parameter: 0}]
      tag: p
    - .isel: [!dag_tag parameters, {parameter: 1}]
      tag: t
    - .isel: [!dag_tag parameters, {parameter: 2}]
      tag: sigma
  to_plot:
    [0, 0]:
      - function: sns.histplot
        data: !dag_result p
    [1, 0]:
      - function: sns.histplot
        data: !dag_result t
    [2, 0]:
      - function: sns.histplot
        data: !dag_result sigma
  color: !dag_result c_darkblue
  linewidth: 0.5
  helpers:
    axis_specific:
      0:
        axis: [0, 0]
        set_labels:
          x: $\beta$
      1:
        axis: [ 1, 0 ]
        set_labels:
          x: $\tau$
      2:
        axis: [ 2, 0 ]
        set_labels:
          x: $\sigma$
    setup_figure:
      nrows: 1
      ncols: 3
    set_labels:
      y: ' '
  compute_only: []
  style:
    figure.figsize: [!dag_result full_width, !dag_result quarter_width]

# Plot the predictions over time, colour-coded by loss
predictions:
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.scatter
  select_and_combine:
    fields:
      parameters:
        path: parameters
        transform: [.data]
      loss:
        path: loss
        transform: [.data]
  transform:
    - broadcast: [!dag_tag parameters, !dag_tag loss]
      kwargs:
        exclude_dim: [seed]
    - flatten_dims: [!dag_prev ]
      kwargs:
        dims: {batch: [batch, seed]}
      tag: data
  x: batch
  y: x
  hue: loss
  col: parameter
  s: 2
  sharey: False # Seems to have no effect?
  sharex: False
  helpers:
    set_limits:
      x: [min, max]
      y: [0, max] # Why is this necessary?
  add_legend: False
  norm:
    name: LogNorm
  vmax: 100
  cmap:
    <<: *cmap

# Plot the loss landscape of the parameters, colour-coded by loss
probability_landscape:
  based_on: predictions
  add_legend: False
  select_and_combine:
    fields:
      loss:
        transform:
          - mul: [!dag_prev , -1]
          - np.exp: [!dag_prev ]
  x: x
  y: loss
  hue: loss
  s: 2
  norm: ~
  vmax: ~
  cbar_kwargs:
    label: Unnormalised probability
