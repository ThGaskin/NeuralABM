# Plot the marginal distributions over the parameters
marginals:
  based_on:
    - .marginal_mv
    - .plot.facet_grid.density
  transform:

    # Scale the loss values by the median; this is necessary to prevent
    # numerical underflow arising from the exponentiation of very small values
    # Broadcast loss and parameters into a common dataset
    - .median: [!dag_tag loss , ['seed', 'epoch']]
    - div: [!dag_tag loss, !dag_prev ]
    - mul: [!dag_prev , -1]
    - np.exp: [!dag_prev ]
    - broadcast: [!dag_tag parameters, !dag_prev ]

    # Get the bin edges and ranges for each parameter:
    # the intervals given by the prior, and a high bin count to ensure points that are not equal are not
    # averaged together
    - xr.DataArray:
        data: [[0, 2, 500000], [0, 6, 500000], [1, 3, 500000], [0, 0.5, 500000]]
        dims: ['parameter', 'idx']
        coords: {parameter: [alpha, beta, kappa, sigma]}
    - .coords: [!dag_node -2, 'noise']
    - .expand_dims: [!dag_node -2 , {noise: !dag_prev }]


    # Compute the marginals on a very fine grid and aggregate into a coarser grid
    - compute_marginal: [!dag_node -4 , !dag_prev ]
      kwargs:
        x: x
        p: loss
        exclude_dim: [parameter, noise]
        statistic: mean
        aggregate: 100
      file_cache:
        write: True
        read: True
      tag: data

  sharex: False
  sharey: False
  c: !dag_result c_darkblue

  # Aggreate to a resolution of 100 bins
  smooth_kwargs:
    enabled: True
    sigma: 50
  x: x
  y: p
  col: parameter
  row: noise
  figsize: [!dag_result full_width, !dag_result full_width]

  helpers:
    set_labels:
      y: ' '
      x: ' '

# Plot the predictions of the parameters, colour-coded by loss
predictions:
  based_on:
    - .creator.multiverse
    - .plot.facet_grid.scatter
  add_legend: False
  select_and_combine:
    fields:
      parameters:
        path: parameters
        transform: [.data]
      loss:
        path: loss
        transform: [.data]
  transform:
    - broadcast: [!dag_tag parameters, !dag_tag loss]
      kwargs:
        exclude_dim: ['seed', 'noise']
    - flatten_dims: [!dag_prev ]
      kwargs:
        dims: {'iteration': ['epoch', 'seed']}
      tag: data
  col: parameter
  row: noise
  x: iteration
  y: x
  hue: loss
  s: 1
  sharey: False # Seems to have no effect?
  norm:
    name: LogNorm
  cmap:
    continuous: true
    from_values:
      0: !dag_result c_darkblue
      1: !dag_result c_yellow
  helpers:
    set_limits:
      x: [0, max]
      y: [0, max] # Why is this necessary?
