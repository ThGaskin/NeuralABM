diff --git a/README.md b/README.md
index f8a69a0..bc2df98 100644
--- a/README.md
+++ b/README.md
@@ -164,4 +164,11 @@ with the name of a common function, such as ``relu``, ``linear``, ``tanh``, ``si
 ``bias`` controls use of the bias, and the ``init_bias`` sets the initialisation interval for the 
 bias.
 
+## Tests
+All models are tested. To run tests, invoke
+```bash
+pytest tests
+```
+from the main folder.
+
 
diff --git a/include/__init__.py b/include/__init__.py
index 8480044..26347f7 100644
--- a/include/__init__.py
+++ b/include/__init__.py
@@ -1 +1,2 @@
-from .neural_net import NeuralNet
\ No newline at end of file
+from .neural_net import NeuralNet
+from .vector import *
\ No newline at end of file
diff --git a/include/vector.py b/include/vector.py
index e69de29..1a41f47 100644
--- a/include/vector.py
+++ b/include/vector.py
@@ -0,0 +1,83 @@
+import math
+import numpy as np
+import torch
+from typing import Sequence, Union
+
+
+# --- The vector class -----------------------------------------------------------------------------------------------
+class Vector:
+
+    def __init__(self, x: float, y: float):
+        """
+        :param x: the x coordinate
+        :param y: the y coordinate
+        """
+
+        self.x = x
+        self.y = y
+
+    # Magic methods ....................................................................................................
+    def __abs__(self):
+        return math.sqrt(pow(self.x, 2) + pow(self.y, 2))
+
+    def __add__(self, other):
+        return Vector(self.x + other.x, self.y + other.y)
+
+    def __eq__(self, other):
+        return self.x == other.x and self.y == other.y
+
+    def __mul__(self, other):
+        return self.x * other.x + self.y * other.y
+
+    def __mod__(self, other):
+        return Vector(self.x % other.x, self.y % other.y)
+
+    def __neg__(self):
+        return Vector(-self.x, -self.y)
+
+    def __repr__(self) -> str:
+        return f'({self.x}, {self.y})'
+
+    def __sub__(self, other):
+        return Vector(self.x - other.x, self.y - other.y)
+
+    def scalar_mul(self, l: float):
+        self.x *= l
+        self.y *= l
+
+    def normalise(self, *, norm: float = 1):
+        f = norm / self.__abs__()
+        self.scalar_mul(f)
+
+    def within_space(self, space: Union[Sequence, 'Vector']) -> bool:
+        # Checks whether the vector lies within a square domain
+        if isinstance(space, Vector):
+            return (0 <= self.x <= space.x) and (0 <= self.y <= space.y)
+        else:
+            return (space[0][0] <= self.x <= space[0][1]) and (space[1][0] <= self.y <= space[1][1])
+
+
+def distance(v: Vector,
+             w: Vector,
+             *,
+             periodic: bool = False,
+             space: Union[Vector, Sequence] = None,
+             as_tensor: bool = True):
+
+    """ Returns the distance between two vectors v and w. If the space is periodic, the distance is
+    calculated accordingly."""
+
+    if not periodic:
+        return abs(v - w) if not as_tensor else torch.tensor(abs(v - w), dtype=torch.float)
+    else:
+        d = v-w
+
+        if isinstance(space, Vector):
+            L_x, L_y = abs(space.x), abs(space.y)
+        else:
+            L_x, L_y = abs(np.diff(space[0])), abs(np.diff(space[1]))
+
+        dist = math.sqrt(pow(min(abs(d.x), L_x - abs(d.x)), 2) + pow(min(abs(d.y), L_y-abs(d.y)), 2))
+
+        return dist if not as_tensor else torch.tensor(dist, dtype=torch.float)
+
diff --git a/models/HarrisWilson/run.py b/models/HarrisWilson/run.py
index d432f5f..5de5de4 100755
--- a/models/HarrisWilson/run.py
+++ b/models/HarrisWilson/run.py
@@ -7,7 +7,7 @@ import numpy as np
 import ruamel.yaml as yaml
 import time
 import torch
-from utopya._import_tools import import_module_from_path
+from dantro._import_tools import import_module_from_path
 
 sys.path.append(up(up(__file__)))
 sys.path.append(up(up(up(__file__))))
diff --git a/models/SIR/ABM.py b/models/SIR/ABM.py
index 528d5a6..588c5cc 100644
--- a/models/SIR/ABM.py
+++ b/models/SIR/ABM.py
@@ -1,8 +1,15 @@
-import copy
+from os.path import dirname as up
+import sys
 from enum import IntEnum
 import torch
-import math
 import numpy as np
+from dantro._import_tools import import_module_from_path
+
+sys.path.append(up(up(up(__file__))))
+base = import_module_from_path(mod_path=up(up(up(__file__))), mod_str='include')
+
+Vector = base.Vector
+distance = base.distance
 
 """ The SIR agent-based model of infectious diseases """
 
@@ -13,65 +20,6 @@ class kinds(IntEnum):
     RECOVERED = 2
 
 
-# --- The vector class -----------------------------------------------------------------------------------------------
-class Vector:
-
-    def __init__(self, *, x: float, y: float):
-        """
-        :param x: the x coordinate
-        :param y: the y coordinate
-        """
-
-        self.x = x
-        self.y = y
-
-    # Magic methods ....................................................................................................
-    def __abs__(self):
-        return math.sqrt(pow(self.x, 2) + pow(self.y, 2))
-
-    def __add__(self, other):
-        return Vector(x=self.x + other.x, y=self.y + other.y)
-
-    def __mul__(self, other):
-        return self.x * other.x + self.y * other.y
-
-    def __mod__(self, other):
-        return Vector(x=self.x % other.x, y=self.y % other.y)
-
-    def __repr__(self) -> str:
-        return f'({self.x}, {self.y})'
-
-    def __sub__(self, other):
-        return Vector(x=self.x - other.x, y=self.y - other.y)
-
-    def scalar_mul(self, l: float):
-        self.x *= l
-        self.y *= l
-        return self
-
-    def normalise(self, *, norm: float = 1):
-        f = norm / self.__abs__()
-        self.x *= f
-        self.y *= f
-        return self
-
-    def withinspace(self, space) -> bool:
-        # Checks whether the vector lies within a square domain
-        return (0 < self.x < space.x) and (0 < self.y < space.y)
-
-
-def distance(v: Vector, w: Vector, *, periodic: bool, space: Vector = None, as_tensor: bool = True):
-    """ Returns the distance between two vectors v and w. If the space is periodic, the distance is
-    calculated accordingly."""
-    if not periodic:
-        return abs(v - w) if not as_tensor else torch.tensor(abs(v - w), dtype=torch.float)
-    else:
-        d = v-w
-        dist = math.sqrt(pow(min(abs(d.x), abs(d.x - space.x)), 2) + pow(min(abs(d.y), abs(d.y-space.y)), 2))
-
-        return dist if not as_tensor else torch.tensor(dist, dtype=torch.float)
-
-
 # --- The agent class --------------------------------------------------------------------------------------------------
 class Agent:
 
@@ -119,8 +67,8 @@ class Agent:
         """
 
         # Get a random direction in the sphere with radius sigma_i
-        direction = Vector(x=diffusion * (2 * np.random.rand() - 1),
-                           y=diffusion * (2 * np.random.rand() - 1))
+        direction = Vector(diffusion * (2 * np.random.rand() - 1),
+                           diffusion * (2 * np.random.rand() - 1))
 
         # Non-periodic case: move within space, repelling from walls
         if not periodic:
@@ -163,7 +111,7 @@ class SIR_ABM:
         """
 
         # Parameters for the dynamics
-        self.space = Vector(x=space[0], y=space[1])
+        self.space = Vector(space[0], space[1])
         self.is_periodic = is_periodic
         self.sigma_s = sigma_s
         self.sigma_i = sigma_i
@@ -180,8 +128,8 @@ class SIR_ABM:
         # Initialise the agent positions and kinds
         self.agents = {i: Agent(id=i,
                                 kind=self.init_kinds[i],
-                                position=Vector(x=np.random.rand() * self.space.x,
-                                                y=np.random.rand() * self.space.y))
+                                position=Vector(np.random.rand() * self.space.x,
+                                                np.random.rand() * self.space.y))
                        for i in range(self.N)}
 
         # Track the ids of the susceptible, infected, and recovered cells
diff --git a/models/SIR/__init__.py b/models/SIR/__init__.py
index dd051d8..fb5ba19 100644
--- a/models/SIR/__init__.py
+++ b/models/SIR/__init__.py
@@ -1 +1,2 @@
+from .ABM import *
 from .DataGeneration import get_SIR_data, generate_smooth_data
\ No newline at end of file
diff --git a/models/SIR/cfgs/ABM_data/run.yml b/models/SIR/cfgs/ABM_data/run.yml
index 59fae59..111fc47 100644
--- a/models/SIR/cfgs/ABM_data/run.yml
+++ b/models/SIR/cfgs/ABM_data/run.yml
@@ -1,6 +1,3 @@
-perform_sweep: True
-paths:
-  model_note: ABM_data
 parameter_space:
   seed: 0
   num_epochs: 1
diff --git a/models/SIR/run.py b/models/SIR/run.py
index 9785d40..2158d59 100755
--- a/models/SIR/run.py
+++ b/models/SIR/run.py
@@ -6,7 +6,7 @@ import h5py as h5
 import numpy as np
 import ruamel.yaml as yaml
 import torch
-from utopya._import_tools import import_module_from_path
+from dantro._import_tools import import_module_from_path
 
 sys.path.append(up(up(__file__)))
 sys.path.append(up(up(up(__file__))))
diff --git a/tests/SIR/test_ABM.py b/tests/SIR/test_ABM.py
index e69de29..e8ee1f7 100644
--- a/tests/SIR/test_ABM.py
+++ b/tests/SIR/test_ABM.py
@@ -0,0 +1,8 @@
+import pytest
+
+def test_agent_creation():
+    assert (1==1)
+
+def test_agent_movement():
+    assert(1==1)
+
diff --git a/tests/SIR/test_utils.py b/tests/SIR/test_utils.py
index e69de29..69cef36 100644
--- a/tests/SIR/test_utils.py
+++ b/tests/SIR/test_utils.py
@@ -0,0 +1,101 @@
+from os.path import dirname as up
+import sys
+import math
+import pytest
+import numpy as np
+import torch
+
+from dantro._import_tools import import_module_from_path
+
+sys.path.append(up(up(up(__file__))))
+
+vec = import_module_from_path(mod_path=up(up(up(__file__))), mod_str='include.vector')
+Vector = vec.Vector
+distance = vec.distance
+
+# ----------------------------------------------------------------------------------------------------------------------
+# ----------------------------------------------------------------------------------------------------------------------
+
+vectors = [Vector(2, 3), Vector(-1, -4), Vector(0.4, -0.2), Vector(0.0, 0)]
+non_zero_vectors = [Vector(2, 3), Vector(-1, -4), Vector(0.4, -0.2)]
+zero_vector = Vector(0, 0)
+unit_vector = Vector(1, 1)
+
+def test_vector():
+    """ Tests the Vector class"""
+
+    for v in vectors:
+
+        assert v == v
+        assert v != Vector(-1, -1)
+        assert v + zero_vector == v
+
+        assert math.sqrt(v * v) == abs(v)
+        assert v * zero_vector == 0
+
+        assert -(-v) == v
+        assert (abs(-v)) == abs(v)
+
+    assert abs(unit_vector) == math.sqrt(2)
+    assert abs(zero_vector) == 0
+
+    assert vectors[0] + vectors[1] == Vector(1, -1)
+    assert vectors[0] - vectors[1] == Vector(3, 7)
+
+    q = Vector(0., 0.)
+    q.scalar_mul(2.3)
+    assert q == zero_vector
+
+    q = Vector(1., 1.)
+    q.scalar_mul(-math.pi)
+    assert q == Vector(-math.pi, -math.pi)
+
+    for v in non_zero_vectors:
+        v.normalise()
+        assert abs(v) == pytest.approx(1, 1e-8)
+
+        v.normalise(norm=2.5)
+        assert abs(v) == pytest.approx(2.5, 1e-8)
+
+    space_list = [[-10, 10], [-10, 10]]
+    space_np = np.array(space_list)
+    space_torch = torch.from_numpy(space_np)
+    space_slice = [[-20, -10], [-10, -10]]
+    space_small = [[-20, -10], [-10, -9]]
+    for v in vectors:
+        assert v.within_space(space_list)
+        assert v.within_space(space_np)
+        assert v.within_space(space_torch)
+        assert not v.within_space(space_slice)
+        assert not v.within_space(space_small)
+
+    space = Vector(3, 5)
+    assert zero_vector.within_space(space)
+
+
+def test_distances():
+    """ Tests the distance function """
+
+    # Non-periodic case
+    for v in vectors:
+        assert distance(v, zero_vector) == abs(v)
+        assert distance(zero_vector, v) == abs(v)
+        d_tensor = distance(v, zero_vector, as_tensor=True)
+        assert d_tensor == abs(v)
+        assert torch.is_tensor(d_tensor)
+
+    # Periodic case
+    large_space = [[-100, 100], [-100, 100]]
+    for v in vectors:
+        assert distance(v, zero_vector, periodic=True, space=large_space) == abs(v)
+        assert distance(zero_vector, v, periodic=True, space=large_space) == abs(v)
+
+    small_space = [[-2, 2], [-2, 2]]
+    q, p, r, t = Vector(2, 2), Vector(-2, -2), Vector(-2, 2), Vector(2, -2)
+    for v in [p, q, r, t]:
+        for w in [p, q, r, t]:
+            assert distance(v, w, periodic=True, space=small_space) == 0
+
+
+
+